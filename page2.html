<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css" <title>Глава 2</title>
</head>

<body>
    <h1>Работа с шаблонами, статическими файлами и HTML-формами</h1>
<ul>В этой главе мы рассмотрим следующие рецепты:
    <li>Создание первого шаблона</li>
    <li>Обслуживание статических файлов по HTTP</li>
    <li>Обслуживание статических файлов по HTTP с использованием Gorilla Mux</li>
    <li>Создание первой HTML-формы</li>
    <li>Чтение первой HTML-формы</li>
    <li>Проверка первой HTML-формы</li>
    <li>Загрузка первого файла.</li>
</ul>

<h2>Введение</h2>
<p>Довольно часто нам нужно создавать HTML-формы, чтобы получать информацию от клиента
    в определенном формате, загружать файлы или папки на сервер и генерировать общие
    шаблоны HTML, а не повторять один и тот же статический текст. Зная концепции,
    рассмотренные в этой главе, мы сможем эффективно реализовать все эти функции в Go.
    В этой главе мы начнем с создания базового шаблона, а затем перейдем к обслуживанию
    статических файлов, таких как .js, .css и изображений, из файловой системы, а затем создадим, прочитаем
    и проверим HTML-формы и загрузим файл в сервер.</p>

<h2>Создание вашего первого шаблона</h2>
<p>Шаблоны позволяют нам определять заполнители для динамического контента, которые могут быть заменены
    значениями во время выполнения с помощью механизма шаблонов. Затем их можно преобразовать в
    файл HTML и отправить клиенту. Создавать шаблоны в Go довольно просто, используя
    пакет Go html/template, который мы рассмотрим в этом рецепте.</p>

    <h3>Как это сделать ...</h3>
<p>В этом рецепте мы собираемся создать файл first-template.html с парой заполнителей,
    значения которых будут введены шаблонизатором во время выполнения. Выполните следующие
    шаги:</p>
<ol>
    <li>Создайте файл first-template.html в каталоге шаблонов, выполнив следующую
        команду Unix:</li>
        <p class="terminal">

            $ mkdir templates && cd templates && touch first-template.html

        </p>
    <li>Скопируйте следующее содержимое в first-template.html:</li>
    <pre><code>
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;First Template&lt;/title&gt;
        &lt;link rel="stylesheet" href="/static/stylesheets/main.css"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello {{.Name}}!&lt;/h1&gt;
        Your Id is {{.Id}}
    &lt;/body&gt;
&lt;/html&gt;
    </code></pre>
    <p>В предыдущем шаблоне есть два заполнителя: <i>{{.Name}}</i> и <i>{{.Id}}</i>,
        значения которых будут заменены или введены обработчиком шаблонов во время выполнения.</p>
    <li>Создайте файл first-template.go, где мы заполним значения заполнителей,
        сгенерируем HTML-код в качестве вывода и запишем его клиенту следующим образом:</li>
        <pre><code>
package main

import (
    "fmt"
    "html/template"
    "log"
    "net/http"
)

const (
    CONN_HOST = "localhost"
    CONN_PORT = "8080"
)

type Person struct {
    Id string
    Name string
}

func renderTemplate(w http.ResponseWriter, r *http.Request){
    person := Person{Id: "1", Name: "Foo"}
    parsedTemplate, _ := template.ParseFiles("templates/first-template.html")
    err := parsedTemplate.Execute(w, person)

    if err != nil{
        log.Printf("Произошла ошибка при выполнении шаблона или записи его вывода. : ", err)
        return
    }
}

func main(){
    http.HandleFunc("/", renderTemplate)
    err := http.ListenAndServe(CONN_HOST + ":" + CONN_PORT, nil)
    if err != nil{
        log.Fatal("error starting http server : ", err)
        return
    }
}
        </code></pre>
        <p>Если все готово, структура каталогов должна выглядеть следующим образом:</p>
        <p><img src="static/images/picture2-1.png"/></p>
    <li>Запустите программу следующей командой:</li>
    <p class="terminal">

        $ go run first-template.go
        
    </p>
</ol>
<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Просмотр <span>http://localhost:8080</span> покажет нам сообщение Hello Foo! обслуживается шаблонизатором
    , как показано на следующем снимке экрана:/p>
<p><img src="static/images/picture2-2.png"/></p>
<p>Выполните команду <span>curl -X GET http://localhost:8080</span> из командной строки следующим образом:</p>
<p class="terminal">

    debian@debian:~$ curl -X GET http://localhost:8080
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;title&gt;First Template&lt;/title&gt;
            &lt;link rel="stylesheet" href="/static/stylesheets/main.css"&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Hello Foo!&lt;/h1&gt;
            Your Id is 1
        &lt;/body&gt;
    &lt;/html&gt;
    
</p>

<p>Давайте разберемся в написанной нами программе Go:</p>
<ul>
    <li><i>type Person struct { Id string Name string }</i>: Здесь мы определяем тип структуры person, который
        имеет поля Id и Name.</li>
        <p class="note">
            Имя поля в определении типа должно начинаться с заглавной буквы; в противном случае это приведет к ошибкам
и не будет заменено в шаблоне.
        </p>
        <p>Далее мы определили обработчик <i>renderTemplate()</i>, который делает множество вещей.</p>
    <li><i>person := Person{Id: "1", Name: "Foo"}</i>: Здесь мы инициализируем тип структуры person
        с Id как 1 и Name как Foo.</li>
    <li><i>parsedTemplate, _ := template.ParseFiles("templates/first-template.html")</i>: Здесь мы вызываем
        ParseFiles из пакета html/template, который создает новый шаблон и
        анализирует имя файла, которое мы передаем в качестве входных данных, которое является первым -template.html в
        каталоге шаблонов. Результирующий шаблон будет иметь имя и содержимое входного файла.</li>
    <li><i>err := parsedTemplate.Execute(w, person)</i>: Здесь мы вызываем обработчик Execute для
        проанализированного шаблона, который вводит данные о человеке в шаблон, генерирует
        выходные данные HTML и записывает их в поток ответов HTTP.</li>
    <li><i>if err != nil {log.Printf("Произошла ошибка при выполнении шаблона или записи его
        вывода: ", err) return }</i>: Здесь мы проверяем, есть ли какие-либо проблемы при
        выполнении шаблона или записи его вывода в поток ответов. Если есть,
        то мы регистрируем ошибку и выходим с кодом состояния 1.</li>
</ul>

<h2>Обслуживание статических файлов через HTTP</h2>
<p>При разработке веб-приложений всегда рекомендуется обслуживать статические ресурсы,
    такие как .js, .css и изображения, из файловой системы или любой сети доставки контента
    (CDN), например Amazon CloudFront, а не обслуживать их из веб-
    сервер. Это связано с тем, что все эти типы файлов являются статическими и не нуждаются в
    обработке; так зачем нам создавать дополнительную нагрузку на сервер? Более того, это помогает повысить
    производительность приложений, поскольку все запросы к статическим файлам будут обслуживаться из
    внешних источников и, следовательно, снижать нагрузку на сервер.</p>
<p>Пакета net/http Go достаточно для обслуживания статических ресурсов файловой системы через FileServer,
     что мы и рассмотрим в этом рецепте.</p>
<p>Поскольку в предыдущем рецепте мы уже создали шаблон, мы просто расширим его для
    обслуживания статического файла .css из каталога static/css.</p>

<h3>Как это сделать ...</h3>
<p>В этом рецепте мы собираемся создать файловый сервер, который будет обслуживать статические ресурсы
    файловой системы. Выполните следующие шаги:</p>
    <ol>
        <li>Создайте main.css внутри каталога static/css следующим образом:</li>
        <p class="terminal">
            $ mkdir static && cd static && mkdir css && cd css && touch main.css
        </p>
        <li>Скопируйте следующее содержимое в main.css:</li>
        <pre><code>
            body {color: #00008B}
        </code></pre>
        <li>Создайте файл own-static-files.go, где мы создадим FileServer, который будет обслуживать
            ресурсы из каталога static/css, присутствующего в файловой системе, для всех
            шаблонов URL-адресов с /static, следующим образом:</li>
            <pre><code>
    package main

    import (
        "fmt"
        "html/template"
        "log"
        "net/http"
    )

    const (
        CONN_HOST = "localhost"
        CONN_PORT = "8080"
    )

    type Person struct {
        Name string
        Age string
    }

    func renderTemplate(w http.ResponseWriter, r *http.Request){
        person := Person{Id: "1", Name: "Foo"}

        parsedTemplate, _ := template.ParseFiles("templates/first-template.html")
        
        err := parsedTemplate.Execute(w, person)
        if err != nil {
            log.Printf("Произошла ошибка при выполнении шаблона или записи его вывода. : ", err)
            return
        }
    }

    func main(){
        fileServer := http.FileServer(http.Dir("static"))
        http.Handle("/static/", http.StripPrefix("/static/", fileServer))
        http.HandleFunc("/", renderTemplate)

        err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)
        if err != nil {
            log.Fatal("error starting http server : ", err)
            return
        }
    }
            </code></pre>
        <li>Обновите файл first-template.html (созданный в нашем предыдущем рецепте), включив в него файл main.css из
            каталога static/css:</li>
        <pre><code>
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;title&gt;First Template&lt;/title&gt;
            &lt;link rel="stylesheet" href="/static/css/main.css"&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Hello Foo!&lt;/h1&gt;
            Your Id is 1
        &lt;/body&gt;
    &lt;/html&gt;
        </code></pre>
        <li>Запустите программу следующей командой:</li>
        <p class="terminal">
            $ go run serve-static-files.go
        </p>
    </ol>
<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.
    Просмотр <span>http://localhost:8080</span> покажет нам тот же результат, который мы видели в нашем предыдущем
    рецепте, но на этот раз цвет текста изменился с черного по умолчанию до синего цвета, как
    показано на следующем рисунке:</p>
<p><img src="static/images/picture2-3.png"/></p>
<p>Если мы посмотрим на вкладку «Сеть» в Chrome DevTools, мы увидим файл main.css, который был
    загружен из каталога static/css, присутствующего в файловой системе.</p>
<p>Давайте разберемся с изменениями, которые мы внесли в метод main() в рамках этого рецепта:</p>
<ul>
    <li><i>fileServer := http.FileServer(http.Dir("static"))</i>: Здесь мы создали файловый сервер, используя
        обработчик FileServer пакета net/http, который обслуживает HTTP-запросы из
        статического каталога, присутствующего в файловой системе.</li>
    <li><i>http.Handle("/static/", http.StripPrefix("/static/", fileServer))</i>: Здесь мы регистрируем
        обработчик http.StripPrefix("/static/", fileServer) с шаблоном URL-адреса /static, используя HandleFunc пакета net/http, что означает, что
        http.StripPrefix("/static/", fileServer) выполняется и передает (http.ResponseWriter,
        *http.Request) ему в качестве параметра всякий раз, когда мы обращаемся к URL-адресу HTTP с помощью
        / статический узор.</li>
    <li><i>http.StripPrefix("/static/", fileServer)</i>: возвращает обработчик, который обслуживает HTTP-
        запросы, удаляя /static из пути URL-адреса запроса, и вызывает файловый
        сервер. StripPrefix обрабатывает запрос пути, который не начинается с префикса,
        отвечая HTTP 404.</li>
</ul>

<h2>Обслуживание статических файлов через HTTP с использованием Gorilla Mux</h2>
<p>В предыдущем рецепте мы обслуживали статические ресурсы через файловый сервер HTTP Go. В
    этом рецепте мы рассмотрим, как мы можем обслуживать его через маршрутизатор Gorilla Mux, который
    также является одним из наиболее распространенных способов создания HTTP-маршрутизатора.</p>
<p>Поскольку в нашем предыдущем рецепте мы уже создали шаблон, который обслуживает файл main.css из
    каталога static/css, присутствующего в файловой системе, мы просто обновим его для использования
    маршрутизатора Gorilla Mux.</p>

<h3>Как это сделать ...</h3>    
<ol>
    <li>Установите пакет <span>github.com/gorilla/mux</span> с помощью команды go get следующим образом:</li>
    <p class="terminal">
        $ go get github.com/gorilla/mux
    </p>
    <li>Создайте own-static-files-gorilla-mux.go, где мы создадим маршрутизатор Gorilla Mux
        вместо HTTP FileServer, как показано ниже:</li>
        <pre><code>
    package main

    import (
        "html/template"
        "log"
        "net/http"
        "github.com/gorilla/mux"
    )

    const (
        CONN_HOST = "localhost"
        CONN_PORT = "8080"
    )

    type Person struct {
        Id string
        Name string
    }

    func renderTemplate(w http.ResponseWriter, r *http.Request){
        person := Person{Id: "1", Name: "Foo"}
        
        parsedTemplate, _ := template.ParseFiles("templates/first-template.html")
        
        err := parsedTemplate.Execute(w, person)
        if err != nil {
            log.Printf("Error occurred while executing the template or writing its output : ", err)
            return
        }
    }

    func main() {
        router := mux.NewRouter()
        
        router.HandleFunc("/", renderTemplate).Methods("GET")
        router.PathPrefix("/").Handler(http.StripPrefix("/static", http.FileServer(http.Dir("static/"))))
        
        err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
        if err != nil {
            log.Fatal("error starting http server : ", err)
            return
        }
    }
        </code></pre>
    <li>Запустите программу следующей командой:</li>
    <p class="terminal">
        $ go run serve-static-files-gorilla-mux.go
    </p>
</ol>

<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Просмотр <span>http://localhost:8080</span> покажет нам тот же результат, который мы видели в нашем предыдущем
    рецепте, как показано на следующем снимке экрана:</p>
<p><img src="static/images/picture2-3.png"/></p>
<p>Давайте разберемся с изменениями, которые мы внесли в метод main() в рамках этого рецепта:</p>
<ul>
    <li><i>router :=mux.NewRouter()</i>: Здесь мы создали экземпляр маршрутизатора gorilla/mux, вызвав
        обработчик NewRouter() мультиплексора.</li>
    <li><i>router.HandleFunc("/",renderTemplate).Methods("GET")</i>: Здесь мы зарегистрировали шаблон URL-адреса /
        с помощью обработчика renderTemplate. Это означает, что renderTemplate будет выполняться для
        каждого запроса с шаблоном URL-адреса /.</li>
    <li><i>router.PathPrefix("/").Handler(http.StripPrefix("/static",http.FileServer(http.Dir("static/"))))</i>: Здесь мы регистрируем / как новый маршрут вместе
        с установкой обработчик, который будет выполнен после его вызова.</li>
    <li><i>http.StripPrefix("/static", http.FileServer(http.Dir("static/")))</i>: возвращает обработчик,
        который обслуживает HTTP-запросы, удаляя /static из пути URL-адреса запроса и
        вызывая файловый сервер. StripPrefix обрабатывает запрос пути, который не начинается
        с префикса, отвечая HTTP 404.</li>
</ul>

<h2>Создание вашей первой HTML-формы</h2>
<p>Всякий раз, когда мы хотим получить данные от клиента и отправить их на сервер для
    обработки, лучшим выбором будет реализация HTML-формы. Об этом мы и поговорим
    в этом рецепте.</p>
<p>В этом рецепте мы создадим простую HTML-форму с двумя полями ввода и кнопкой
    для отправки формы. Выполните следующие шаги:</p>
<ol>
    <li>Создайте файл login-form.html в каталоге шаблонов следующим образом:</li>
    <p class="terminal">
        $ mkdir templates && cd templates && touch login-form.html
    </p>
    <li>Скопируйте следующее содержимое в файл login-form.html:</li>
    <pre><code>
&lt;html&gt;
    &lt;head&gt;
        ;First Form&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Login&lt;/h1&gt;
        &lt;form method="post" action="/login"&gt;
            &lt;label for="username"&gt;Username&lt;/label&gt;
            &lt;input type="text" id="username" name="username"&gt;
            &lt;label for="password"&gt;Password&lt;/label&gt;
            &lt;input type="password" id="password" name="password"&gt;
            &lt;button type="submit"&gt;Login&lt;/button&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </code></pre>
    <p>Предыдущий шаблон имеет два текстовых поля — имя пользователя и пароль — а также
        кнопку «Войти».</p>
    <p>При нажатии кнопки «Войти» клиент выполнит POST-вызов действия,
        определенного в форме HTML, в нашем случае это /login.</p>
    <li>Создайте html-form.go, где мы будем анализировать шаблон формы и записывать его в
        поток ответов HTTP следующим образом:</li>
        <pre><code>
    package main

    import(
        "html/template"
        "log"
        "net/http"
    )
    
    const (
        CONN_HOST = "localhost"
        CONN_PORT = "8080"
    )

    func login(w http.ResponseWriter, r *http.Request){
        parsedTemplate, _ := template.ParseFiles("templates/login-form.html")
        parsedTemplate.Execute(w, nil)
    }

    func main(){
        http.HandleFunc("/", login)
        
        err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)
        if err != nil{
            log.Fatal("error starting http server : ", err)
        return
        }
    }
        </code></pre>
    <li>Запустите программу следующей командой:</li>
    <p class="terminal">
        $ go run html-form.go
    </p>
</ol>

<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Просмотр <span>http://localhost:8080</span> покажет нам HTML-форму, как показано на следующем
    снимке экрана:</p>
<p><img src="static/images/picture2-4.png"</p>
<p>Давайте разберемся в написанной нами программе:</p>
<ul>
    <li><i>func login(w http.ResponseWriter, r *http.Request) { parsedTemplate, _ :=
        template.ParseFiles("templates/login-form.html") parsedTemplate.Execute(w, nil) }</i>: это
        функция Go, которая принимает ResponseWriter и Request в качестве входных параметров, анализирует
        файл login-form.html и возвращает новый шаблон.</li>
    <li><i>http.HandleFunc("/", login)</i>: здесь мы регистрируем функцию входа в систему с
        шаблоном / URL-адреса, используя HandleFunc пакета net/http, что означает, что функция входа
        выполняется каждый раз, когда мы обращаемся к URL-адресу HTTP с шаблоном /.
        передавая ему ResponseWriter и Request в качестве параметров.</li>
    <li><i>err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)</i>: Здесь мы вызываем
        http.ListenAndServe для обслуживания HTTP-запросов, которые обрабатывают каждое входящее
        соединение в отдельной Goroutine. ListenAndServe принимает два параметра —
        адрес сервера и обработчик, где адрес сервера — localhost:8080, а
        обработчик — nil.</li>
    <li><i>if err != nil { log.Fatal("ошибка запуска http-сервера: ", err) return}</i>: Здесь мы проверяем, есть ли
        проблема с запуском сервера. Если да, зарегистрируйте ошибку и выйдите
        с кодом состояния 1.</li>
</ul>


<h2>Чтение вашей первой HTML-формы............</h2>
</body>
</html>