<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="static/css/main.css">
    <title>Глава 4</title>
</head>

<body>
    <h1>Написание и использование веб-сервисов RESTful на Go</h1>
<p>В этой главе мы рассмотрим следующие рецепты:</p>
<ul>
    <li>Cоздание первого метода HTTP GET</li>
    <li>Создание первого метода HTTP POST</li>
    <li>Создание первого метода HTTP PUT</li>
    <li>Создание первого метода HTTP DELETE</li>
    <li>Управление версиями вашего REST API</li>
    <li>Создание первого клиента REST</li>
    <li>Cоздание первого клиента AngularJS</li>
    <li>Cоздание ваш первый клиент ReactJS</li>
    <li>Создание вашего первого клиента VueJS</li>
</ul>
    
<h2>Введение</h2>
<p>Всякий раз, когда мы создаем веб-приложение, инкапсулирующее логику, которая может быть полезна
    другим связанным приложениям, мы часто также пишем и используем веб-сервисы. Это
    связано с тем, что они предоставляют функциональные возможности по сети, доступной через
    протокол HTTP, что делает приложение единым источником достоверной информации.</p>
<p>В этой главе мы напишем RESTful API, который поддерживает
    HTTP-методы GET, POST, PUT и DELETE, а затем узнаем, как создавать версии REST API,
    что очень полезно при создании API, используемых публично. Мы закончим
    написание REST-клиента для их использования.</p>


<h2>Создание вашего первого метода HTTP GET</h2>
<p>При написании веб-приложений нам часто приходится предоставлять наши сервисы клиенту или пользовательскому
    интерфейсу, чтобы они могли использовать фрагмент кода, работающий в другой системе.
    Предоставление доступа к службе может быть выполнено с помощью методов протокола HTTP. Из множества
    методов HTTP в этом рецепте мы научимся реализовывать метод HTTP GET.</p>

<h3>Как это сделать ...</h3> 

<ol>
    <li>Установите пакет github.com/gorilla/mux с помощью команды go get следующим образом:</li>
    <p class="terminal">
        $ go get github.com/gorilla/mux
    </p>
    <li>Создайте http-rest-get.go, где мы определим два маршрута — <i>/employee</i> и
        <i>/employee/{id}</i> вместе с их обработчиками. Первый записывает статический массив
        сотрудников, а второй записывает сведения о сотрудниках для предоставленного идентификатора в
        поток ответов HTTP следующим образом:</li>
        <pre><code>
    package main

    import(
        "encoding/json"
        "log"
        "net/http"
        "github.com/gorilla/mux"
    )

    const(
        CONN_HOST = "localhost"
        CONN_PORT = "8080"
    )

    type Route struct{
        Name string
        Method string
        Pattern string
        HandlerFunc http.HandlerFunc
    }

    type Routes []Route

    var routes = Routes{
        Route {
            "getEmployees",
            "GET",
            "/employees",
            getEmployees,
        },
        Route {
            "getEmployee",
            "GET",
            "/employee/{id}",
            getEmployee,
        },
    }

    type Employee struct {
        Id string `json:"id"`
        FirstName string `json:"firstName"`
        LastName string `json:"lastName"`
    }

    type Employees []Employee
    
    var employees []Employee
    
    func init(){
        employees = Employees{
            Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
            Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
        }
    }

    func getEmployees(w http.ResponseWriter, r *http.Request){
        json.NewEncoder(w).Encode(employees)
    }

    func getEmployee(w http.ResponseWriter, r *http.Request){
        vars := mux.Vars(r)
        id := vars["id"]
        for _, employee := range employees{
            if employee.Id == id{
                if err := json.NewEncoder(w).Encode(employee); err != nil{
                    log.Print("error getting requested employee :: ", err)
                }
            }
        }
    }

    func AddRoutes(router *mux.Router) *mux.Router{
        for _, route := range routes{
            router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(route.HandlerFunc)
        }
        return router
    }

    func main(){
        muxRouter := mux.NewRouter().StrictSlash(true)
        router := AddRoutes(muxRouter)
    
        err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
        if err != nil{
            log.Fatal("error starting http server :: ", err)
            return
        }
    }
        </code></pre>
    <li>Запустите программу с помощью следующей команды:</li>
        <p class="terminal">
            $ go run http-rest-get.go
        </p>
</ol>

<h3>Как это работает ...</h3>

<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Затем выполнение запроса GET из командной строки следующим образом предоставит вам список всех
    сотрудников:</p>
<p class="terminal">
    $ curl -X GET http://localhost:8080/employees

    [{"id":"1","firstName":"Foo","lastName":"Bar"},
        {"id":"2","firstName":"Baz","lastName":"Qux"}]

</p>

<p>Здесь выполнение запроса GET для определенного идентификатора сотрудника из командной строки следующим образом
    предоставит вам сведения о сотруднике для соответствующего идентификатора:</p>
<p class="terminal">
    $ curl -X GET http://localhost:8080/employee/1

    {"id":"1","firstName":"Foo","lastName":"Bar"}

</p>
<p>Давайте разберемся в написанной нами программе:</p>
<ol>
    <li>Мы использовали импорт («encoding/json» «log» «net/http» «github.com/gorilla/mux»).
        Здесь мы импортировали github.com/gorilla/mux, чтобы создать маршрутизатор Gorilla Mux.</li>
    <li>Далее мы объявили тип структуры Route с четырьмя полями — Name, Method, Pattern и
        HandlerFunc, где Name представляет собой имя метода HTTP, Method представляет
        тип метода HTTP, который может быть GET, POST, PUT, DELETE и т. д. включено, Pattern
        представляет путь URL-адреса, а HandlerFunc представляет обработчик HTTP.</li>
    <li>Далее мы определили два маршрута для запроса GET следующим образом:</li>
    <pre><code>
    var routes = Routes{
        Route{
            "getEmployees",
            "GET",
            "/employees",
            getEmployees,
        },
        Route{
            "getEmployee",
            "GET",
            "/employee/{id}",
            getEmployee,
        },
    }
    </code></pre>
    <li>Далее мы определили статический массив «Сотрудники» следующим образом:</li>
    <pre><code>
    func init(){
        employees = Employees{
            Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
            Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
        }
    }
    </code></pre>
    <li>Затем мы определили два обработчика — getEmployes и getEmployee, где первый просто
        маршалирует статический массив сотрудников и записывает его в поток ответов HTTP,
        а второй получает идентификатор сотрудника из переменной запроса HTTP, извлекает сотрудника
        для соответствующего идентификатора из массив, маршалирует объект и записывает
        его в поток ответов HTTP.</li>
    <li>После обработчиков мы определили функцию AddRoutes, которая перебирает
        определенный нами массив маршрутов, добавляет его в маршрутизатор gorilla/mux и возвращает объект Router
        .</li>
    <li>Наконец, мы определили функцию main(), в которой мы создаем экземпляр маршрутизатора gorilla/mux с использованием
        обработчика NewRouter() с конечным слэшем для новых маршрутов как true, что
        означает, что приложение всегда будет видеть путь, указанный в маршруте. Например
        , если путь маршрута — /path/, доступ к /path будет перенаправляться на первый и
        наоборот.</li>
</ol>

<h2>Создание вашего первого метода HTTP POST</h2>

<p>Всякий раз, когда нам нужно отправить данные на сервер посредством асинхронного вызова или
    через форму HTML, мы используем реализацию метода HTTP POST,
    которую мы рассмотрим в этом рецепте.</p>
<h3>Как это сделать ...</h3>
<ol>
    <li>Установите пакет github.com/gorilla/mux с помощью команды go get следующим образом:</li>
        <p class="terminal">
            $ go get github.com/gorilla/mux
        </p>
    <li>Создайте http-rest-post.go, где мы определим дополнительный маршрут, поддерживающий
        метод HTTP POST, и обработчик, который добавляет сотрудника в исходный статический массив
        сотрудников и записывает обновленный список в поток ответов HTTP, как показано ниже:</li>
        <pre><code>
    package main
    
    import(
        "encoding/json"
        "log"
        "net/http"
        "github.com/gorilla/mux"
    )

    const(
        CONN_HOST = "localhost"
        CONN_PORT = "8080"
    )

    type Route struct{
        Name string
        Method string
        Pattern string
        HandlerFunc http.HandlerFunc
    }

    type Routes []Route
    
    var routes = Routes{
        Route{
            "getEmployees",
            "GET",
            "/employees",
            getEmployees,
        },
        Route{
            "addEmployee",
            "POST",
            "/employee/add",
            addEmployee,
        },
    }

    type Employee struct{
        Id string `json:"id"`
        FirstName string `json:"firstName"`
        LastName string `json:"lastName"`
    }

    type Employees []Employee
    
    var employees []Employee
    
    func init(){
        employees = Employees{
            Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
            Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
        }
    }

    func getEmployees(w http.ResponseWriter, r *http.Request){
        json.NewEncoder(w).Encode(employees)
    }

    func addEmployee(w http.ResponseWriter, r *http.Request){
        employee := Employee{}
        err := json.NewDecoder(r.Body).Decode(&employee)
        if err != nil{
            log.Print("error occurred while decoding employee data :: ", err)
            return
        }
        log.Printf("adding employee id :: %s with firstName as :: %s and lastName as :: %s ", 
                                                    employee.Id, employee.FirstName, employee.LastName)
    
        employees = append(employees, Employee{Id: employee.Id, FirstName: employee.FirstName, 
                                                                            LastName: employee.LastName})
        json.NewEncoder(w).Encode(employees)
    }

    func AddRoutes(router *mux.Router) *mux.Router{
        for _, route := range routes{
            router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(route.HandlerFunc)
        }
        return router
    }

    func main(){
        muxRouter := mux.NewRouter().StrictSlash(true)
    
        router := AddRoutes(muxRouter)
    
        err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
        if err != nil{
            log.Fatal("error starting http server :: ", err)
            return
        }
    }
        </code></pre>
    <li>Запустите программу с помощью следующей команды:</li>
        <p class="terminal">
            $ go run http-rest-post.go
        </p>
</ol>

<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Затем выполнение запроса POST из командной строки следующим образом добавит сотрудника
    в список с идентификатором 3 и вернет список сотрудников в качестве ответа:</p>

<p class="terminal">
    $ curl -H "Content-Type: application/json" -X POST -d '{"Id":"3", "firstName":"Quux",
            "lastName":"Corge"}' http://localhost:8080/employee/add

</p>
<p>Это показано на следующем скриншоте:</p>
<p><img src="static/images/picture4-1.png"</p>
<p>Давайте разберемся с изменениями, которые мы внесли в этот рецепт:</p>
<ol>
    <li>Во-первых, мы добавили еще один маршрут с именем addEmployee, который выполняет
        обработчик addEmployee для каждого POST-запроса для шаблона URL-адреса /employee/add.</li>
    <li>Затем мы определили обработчик addEmployee, который в основном декодирует
        данные о сотруднике, поступающие как часть запроса POST, с помощью обработчика NewDecoder встроенного пакета кодирования/json Go, добавляет их в исходный статический массив сотрудника и записывает их
        . в поток ответов HTTP.</li>
</ol>

<h2>Создание вашего первого метода HTTP PUT</h2>
<p>Всякий раз, когда мы хотим обновить запись, которую мы создали ранее, или хотим создать
    новую запись, если она не существует, что часто называется Upsert, мы используем
    реализацию метода HTTP PUT, которую мы рассмотрим в этом рецепте.</p>

<ol>
    <li>Установите пакет github.com/gorilla/mux с помощью команды go get следующим образом:</li>
    <p class="terminal">
        $ go get github.com/gorilla/mux
    </p>
    <li>Создайте http-rest-put.go, где мы определим дополнительный маршрут, поддерживающий
        метод HTTP PUT, и обработчик, который либо обновляет сведения о сотруднике для
        предоставленного идентификатора, либо добавляет сотрудника в исходный статический массив сотрудников; если идентификатор
        не существует, маршалируйте его в JSON и записывайте в поток ответов HTTP
        следующим образом:</li>
        <pre><code>
    package main

    import(
        "encoding/json"
        "log"
        "net/http"
        "github.com/gorilla/mux"
    )

    const(
        CONN_HOST = "localhost"
        CONN_PORT = "8080"
    )

    type Route struct{
        Name string
        Method string
        Pattern string
        HandlerFunc http.HandlerFunc
    }

    type Routes []Route
    
    var routes = Routes{
        Route{
            "getEmployees",
            "GET",
            "/employees",
            getEmployees,
        },
        Route{
            "addEmployee",
            "POST",
            "/employee/add",
            addEmployee,
        },
        Route{
            "updateEmployee",
            "PUT",
            "/employee/update",
            updateEmployee,
        },
    }

    type Employee struct{
        Id string `json:"id"`
        FirstName string `json:"firstName"`
        LastName string `json:"lastName"`
    }

    type Employees []Employee
    
    var employees []Employee
    
    func init(){
        employees = Employees{
            Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
            Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
        }
    }

    func getEmployees(w http.ResponseWriter, r *http.Request){
        json.NewEncoder(w).Encode(employees)
    }

    func updateEmployee(w http.ResponseWriter, r *http.Request){
        employee := Employee{}
        err := json.NewDecoder(r.Body).Decode(&employee)
        if err != nil{
            log.Print("error occurred while decoding employee data :: ", err)
            return
        }
        var isUpsert = true
        for idx, emp := range employees{
            if emp.Id == employee.Id{
                isUpsert = false
                log.Printf("updating employee id :: %s with firstName as :: %s and lastName as:: %s ",
                                                    employee.Id, employee.FirstName, employee.LastName)
                employees[idx].FirstName = employee.FirstName
                employees[idx].LastName = employee.LastName
                break
            }
        }
        if isUpsert{
            log.Printf("upserting employee id :: %s with firstName as :: %s and lastName as:: %s ", 
                                                    employee.Id, employee.FirstName, employee.LastName)
            employees = append(employees, Employee{Id: employee.Id, 
                                            FirstName: employee.FirstName, LastName: employee.LastName})
        }
        json.NewEncoder(w).Encode(employees)
    }

    func addEmployee(w http.ResponseWriter, r *http.Request){
        employee := Employee{}
        err := json.NewDecoder(r.Body).Decode(&employee)
        if err != nil{
            log.Print("error occurred while decoding employee data :: ", err)
            return
        }
        log.Printf("adding employee id :: %s with firstName as :: %s and lastName as :: %s ", employee.Id, 
                                                                    employee.FirstName, employee.LastName)
        employees = append(employees, Employee{Id: employee.Id, FirstName: employee.FirstName,
                                                                    LastName: employee.LastName})
        json.NewEncoder(w).Encode(employees)
    }

    func AddRoutes(router *mux.Router) *mux.Router{
        for _, route := range routes{
            router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(route.HandlerFunc)
        }
        return router
    }

    func main(){
        muxRouter := mux.NewRouter().StrictSlash(true)
    
        router := AddRoutes(muxRouter)
    
        err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
        if err != nil{
            log.Fatal("error starting http server :: ", err)
            return
        }
    }
        </code></pre>
    <li>Запустите программу следующей командой:</li>
    <p class="terminal">
        $ go run http-rest-put.go
    </p>
</ol>

<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Затем, выполнив запрос PUT из командной строки следующим образом, обновится
    имя и фамилия для сотрудника с идентификатором 1:</p>
<p class="terminal">
    $ curl -H "Content-Type: application/json" -X PUT -d '{"Id":"1", "firstName":"Grault",
        "lastName":"Garply"}' http://localhost:8080/employee/update
</p>
<p>Это можно увидеть на следующем скриншоте:</p>
<p><img src="static/images/picture4-2.png"</p>

<p>Если мы выполним запрос PUT для сотрудника с идентификатором 3 из командной строки следующим образом
    , он добавит в массив еще одного сотрудника, поскольку сотрудника с идентификатором 3 нет,
    что демонстрирует сценарий обновления:</p>
<p class="terminal">
    $ curl -H "Content-Type: application/json" -X PUT -d '{"Id":"3", "firstName":"Quux", 
            "lastName":"Corge"}' http://localhost:8080/employee/update
</p>
<p>Это можно увидеть на следующем скриншоте:</p>
<p><img src="static/images/picture4-3.png"</p>
<p>Давайте разберемся с изменениями, которые мы внесли в этот рецепт:</p>
<ol>
    <li>Во-первых, мы добавили еще один маршрут с именем updateEmployee, который выполняет
        обработчик updateEmployee для каждого запроса PUT для шаблона URL-адреса /employee/update.</li>
    <li>Затем мы определили обработчик updateEmployee, который в основном декодирует
        данные о сотрудниках, поступающие как часть запроса PUT, с использованием обработчика NewDecoder встроенного
        пакета кодирования/json Go, перебирает массив сотрудников, чтобы узнать,
        запрошен ли идентификатор сотрудника. существует в исходном статическом массиве сотрудников, который
        мы также можем назвать сценарием UPDATE или UPSERT, выполняет необходимое
        действие и записывает ответ в поток ответов HTTP.</li>
</ol>

<h2>Создание вашего первого метода HTTP  DELETE</h2>

<p>Всякий раз, когда мы хотим удалить запись, которая больше не требуется, мы используем
    реализацию метода HTTP DELETE, которую мы рассмотрим в этом рецепте.</p>

<h3>Как это сделать...</h3>
<ol>
    <li>Установите пакет github.com/gorilla/mux, используя команду go get следующим образом:</li>
    <p class="terminal">
        $ go get github.com/gorilla/mux
    </p>
    <li>Создайте http-rest-delete.go, где мы определим маршрут, поддерживающий
        метод HTTP DELETE, и обработчик, который удаляет сведения о сотруднике для предоставленного идентификатора
        из статического массива сотрудников, маршалирует массив в JSON и записывает его в
        Поток ответа HTTP, например:</li>
        <pre><code>
package main

import(
    "encoding/json"
    "log"
    "net/http"
    "github.com/gorilla/mux"
)

const(
    CONN_HOST = "localhost"
    CONN_PORT = "8080"
)

type Route struct{
    Name string
    Method string
    Pattern string
    HandlerFunc http.HandlerFunc
}

type Routes []Route

var routes = Routes{
    Route{
        "getEmployees",
        "GET",
        "/employees",
        getEmployees,
    },
    Route{
        "addEmployee",
        "POST",
        "/employee/add/",
        addEmployee,
    },
    Route{
        "deleteEmployee",
        "DELETE",
        "/employee/delete",
        deleteEmployee,
    },
}

type Employee struct{
    Id          string `json:"id"`
    FirstName   string `json:"firstName"`
    LastName    string `json:"lastName"`
}

type Employees []Employee

var employees []Employee

func init(){
    employees = Employees{
        Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
    Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
    }
}

func getEmployees(w http.ResponseWriter, r *http.Request){
    json.NewEncoder(w).Encode(employees)
}

func deleteEmployee(w http.ResponseWriter, r *http.Request){
    employee := Employee{}
    err := json.NewDecoder(r.Body).Decode(&employee)
    if err != nil{
        log.Print("error occurred while decoding employee data :: ", err)
        return
    }
    log.Printf("deleting employee id :: %s with firstName as :: %s and lastName as :: %s ", employee.Id, 
                                                                employee.FirstName, employee.LastName)
    index := GetIndex(employee.Id)
    employees = append(employees[:index], employees[index+1:]...)
    json.NewEncoder(w).Encode(employees)
}

func GetIndex(id string) int{
    for i := 0; i < len(employees); i++{
        if employees[i].Id == id{
            return i
        }
    }
    return -1
}

func addEmployee(w http.ResponseWriter, r *http.Request){
    employee := Employee{}
    err := json.NewDecoder(r.Body).Decode(&employee)
    if err != nil{
        log.Print("error occurred while decoding employee data :: ", err)
        return
    }
    log.Printf("adding employee id :: %s with firstName as :: %s and lastName as :: %s ", employee.Id, 
                                                                employee.FirstName, employee.LastName)
    employees = append(employees, Employee{Id: employee.Id, FirstName: employee.FirstName,
                                                                    LastName: employee.LastName})
    json.NewEncoder(w).Encode(employees)
}

func AddRoutes(router *mux.Router) *mux.Router{
    for _, route := range routes{
        router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(route.HandlerFunc)
    }
    return router
}

func main(){
    muxRouter := mux.NewRouter().StrictSlash(true)
    router := AddRoutes(muxRouter)
    
    err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
    if err != nil{
        log.Fatal("error starting http server :: ", err)
        return
    }
}
        </code></pre>
    <li>Запустите программу с помощью следующей команды:</li>
    <p class="terminal">
        $ go run http-rest-delete.go
    </p>
</ol>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Затем, выполнив запрос DELETE из командной строки следующим образом, мы удалит сотрудника
    с идентификатором 1 и предоставит нам обновленный список сотрудников:</p>

<p class="terminal">
    curl -H "Content-Type: application/json" -X DELETE -d '{"Id":"1", "firstName": "Foo",
            "lastName":"Bar"}' http://localhost:8080/employee/delete</p>
<p>Это можно увидеть на следующем скриншоте:</p>
<p><img src="static/images/picture4-4.png" </p>

<ol>
    <li>Во-первых, мы добавили еще один маршрут с именем deleteEmployee, который выполняет
        обработчик deleteEmployee для каждого запроса DELETE для шаблона URL-адреса /employee/delete.</li>
    <li>Во-первых, мы добавили еще один маршрут с именем deleteEmployee, который выполняет
        обработчик deleteEmployee для каждого запроса DELETE для шаблона URL-адреса /employee/delete.</li>
</ol>

<h2>Управление версиями вашего REST API</h2>

<p>Когда вы создаете RESTful API для обслуживания внутреннего клиента, вам, вероятно, не придется
    беспокоиться о версии вашего API. Если пойти еще дальше, если вы контролируете
    всех клиентов, обращающихся к вашему API, то же самое может быть правдой.</p>
<p>Однако в случае, если у вас есть общедоступный API или API, где вы не можете
    контролировать каждого клиента, использующего его, может потребоваться управление версиями вашего API, поскольку
    бизнесу необходимо развиваться, и это мы рассмотрим в этом рецепте.</p>

<h3>Как это сделать ...</h3>
<ol>
    <li>Установите пакет github.com/gorilla/mux, используя команду go get следующим образом:</li>
        <p class="terminal">
           $ go get github.com/gorilla/mux
        </p>
    <li>Создайте http-rest-versioning.go, где мы определим две версии одного и того же URL-
        пути, поддерживающие метод HTTP GET, причем одна будет иметь префикс v1, а другая
        — префикс v2 в маршруте, как показано ниже:</li>
        <pre><code>
package main

import(
    "encoding/json"
    "log"
    "net/http"
    "strings"
    "github.com/gorilla/mux"
)

const(
    CONN_HOST = "localhost"
    CONN_PORT = "8080"
)

type Route struct{
    Name        string
    Method      string
    Pattern     string
    HandlerFunc http.HandlerFunc
}

type Routes []Route

var routes = Routes{
    Route{
        "getEmployees",
        "GET",
        "/employees",
        getEmployees,
    },
}

type Employee struct{
    Id          string `json:"id"`
    FirstName   string `json:"firstName"`
    LastName    string `json:"lastName"`
}

type Employees  []Employee

var employees   []Employee

var employeesV1 []Employee

var employeesV2 []Employee

func init(){
    employees = Employees{
        Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
    }
    employeesV1 = Employees{
        Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
        Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
    }
    employeesV2 = Employees{
        Employee{Id: "1", FirstName: "Baz", LastName: "Qux"},
        Employee{Id: "2", FirstName: "Quux", LastName: "Quuz"},
    }
}

func getEmployees(w http.ResponseWriter, r *http.Request){
    if strings.HasPrefix(r.URL.Path, "/v1"){
        json.NewEncoder(w).Encode(employeesV1)
    } else if strings.HasPrefix(r.URL.Path, "/v2"){
        json.NewEncoder(w).Encode(employeesV2)
    } else {
        json.NewEncoder(w).Encode(employees)
    }
}

func AddRoutes(router *mux.Router) *mux.Router{
    for _, route := range routes{
        router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(route.HandlerFunc)
    }
    return router
}

func main(){
    muxRouter := mux.NewRouter().StrictSlash(true)
    router := AddRoutes(muxRouter)
    // v1
    AddRoutes(muxRouter.PathPrefix("/v1").Subrouter())
    // v2
    AddRoutes(muxRouter.PathPrefix("/v2").Subrouter())

    err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
    if err != nil{
        log.Fatal("error starting http server :: ", err)
        return
    }
}
        </code></pre>
    <li>Запустите программу с помощью следующей команды:</li>
        <p class="terminal">
            $ go run http-rest-versioning.go
        </p>
</ol>

<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>Затем выполнение запроса GET с префиксом пути /v1 из командной строки следующим образом
    предоставит вам список одного набора сотрудников:</p>
    <p class="terminal">
        $ curl -X GET http://localhost:8080/v1/employees

        [{"id":"1","firstName":"Foo","lastName":"Bar"},
                        {"id":"2","firstName":"Baz","lastName":"...

    </p>
<p>Здесь выполнение запроса GET с префиксом пути /v2 предоставит вам список другого набора
    сотрудников, как показано ниже:</p>
    <p class="terminal">
        $ curl -X GET http://localhost:8080/v2/employees
        
        [{"id":"1","firstName":"Baz","lastName":"Qux"},
                {"id":"2","firstName":"Quux","lastName": ...

    </p>
<p>Иногда при разработке URL-адреса REST мы предпочитаем возвращать данные по умолчанию, если клиент
    запрашивает конечную точку без указания версии в пути URL-адреса. Чтобы
    включить его, мы изменили обработчик getEmployees, чтобы он проверял префикс в
    URL-адресе и действовал соответствующим образом. Таким образом, выполнение запроса GET без префикса пути из
    командной строки следующим образом даст вам список с одной записью, которую мы можем назвать
    стандартным или начальным ответом конечной точки REST под названием:</p>
<p class="terminal">
    $ curl -X GET http://localhost:8080/employees
    
    [{"id":"1","firstName":"Foo","lastName":"Bar"}]

</p>
<p>Давайте разберемся с изменениями, которые мы внесли в этот рецепт:</p>
<ol>
    <li>Сначала мы определили один маршрут с именем getEmployees, который выполняет
        обработчик getEmployees для каждого запроса GET для шаблона URL-адреса /employees.</li>
    <li>Затем мы создали три массива, а именно: сотрудники, сотрудникиV1 и сотрудникиV2, которые
        возвращаются в ответ на вызов HTTP GET для шаблонов URL-адресов /employees,
        /v1/employees и /v2/employees соответственно.</li>
    <li>Далее мы определили обработчик getEmployes, в котором мы проверяем префикс в
        URL-пути и выполняем на его основе действие.</li>
    <li>Затем мы определили вспомогательную функцию AddRoutes, которая перебирает
        определенный нами массив маршрутов, добавляет его в маршрутизатор gorilla/mux и возвращает объект Router.</li>
    <li>Наконец, мы определили функцию main(), где мы создаем экземпляр маршрутизатора gorilla/mux, используя
        обработчик NewRouter() с поведением косой черты в конце для новых маршрутов как true, и добавляем
        к нему маршруты, вызывая вспомогательную функцию AddRoutes, передавая маршрутизатор по умолчанию и два
        подмаршрутизатора . , один с префиксом v1, а другой с префиксом v2.</li>
</ol>

<h2>Создание вашего первого REST-клиента</h2>
<p>Сегодня большинство приложений, взаимодействующих с серверами, используют службы RESTful. В зависимости
    от наших потребностей мы используем эти сервисы через JavaScript, jQuery или через
    клиент REST.</p>
<p>В этом рецепте мы напишем REST-клиент, используя пакет <span>//gopkg.in/resty.v1</span>,
    который сам по себе вдохновлен клиентом REST Ruby для использования сервисов RESTful.</p>

<h3>Готовимся ...</h3>
<p>Запустите http-rest-get.go, который мы создали в одном из предыдущих рецептов, в отдельном
    терминале, выполнив следующую команду:</p>
    <p class="terminal">
        $ go run http-rest-get.go
    </p>
    <p class="note">
        См. рецепт «Создание первого метода HTTP GET».
    </p>

<p>Убедитесь, что служба /employees работает локально на порту 8080, выполнив
    следующую команду:</p>
<p class="terminal">
    $ curl -X GET http://localhost:8080/employees

</p>

<p>Это должно вернуть следующий ответ:</p>
<p class="terminal">
    [{"id":"1","firstName":"Foo","lastName":"Bar"},
                    {"id":"2","firstName":"Baz","lastName":"...

</p>

<h3>Как это сделать ...</h3>
<ol>
    <li>Установите пакеты github.com/gorilla/mux и gopkg.in/resty.v1 с помощью
        команды go get следующим образом:</li>
        <p class="terminal">
            $ go get github.com/gorilla/mux
            $ go get -u gopkg.in/resty.v1
        </p>
    <li>Создайте http-rest-client.go, где мы определим обработчики, вызывающие обработчики resty,
        такие как GET, POST, PUT и DELETE, получим ответ от службы REST и запишем
        его в поток ответов HTTP, как показано ниже:</li>
        <pre><code>
package main

import(
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "github.com/gorilla/mux"
    resty "gopkg.in/resty.v1"
)

const(
    CONN_HOST = "localhost"
    CONN_PORT = "8090"
)

const WEB_SERVICE_HOST string = "http://localhost:8080"

type Employee struct{
    Id string `json:"id"`
    FirstName string `json:"firstName"`
    LastName string `json:"lastName"`
}

func getEmployees(w http.ResponseWriter, r *http.Request){
    response, err := resty.R().Get(WEB_SERVICE_HOST + "/employees")
    if err != nil{
        log.Print("error getting data from the web service :: ", err)
        return
    }
    printOutput(response, err)
    fmt.Fprintf(w, response.String())
}

func addEmployee(w http.ResponseWriter, r *http.Request){
    employee := Employee{}
    decodingErr := json.NewDecoder(r.Body).Decode(&employee)
    if decodingErr != nil{
        log.Print("error occurred while decoding employee data :: ", decodingErr)
        return
    }
    log.Printf("adding employee id :: %s with firstName as :: %s and lastName as :: %s ", employee.Id, 
                                                                employee.FirstName, employee.LastName)
    response, err := resty.R().SetHeader("Content-Type", "application/json").
        SetBody(Employee{Id: employee.Id, FirstName:employee.FirstName, LastName: employee.LastName}).
                                                                Post(WEB_SERVICE_HOST + "/employee/add")
    
    if err != nil{
        log.Print("error occurred while adding employee :: ", err)
        return
    }
    printOutput(response, err)
    mt.Fprintf(w, response.String())
}

func updateEmployee(w http.ResponseWriter, r *http.Request){
    employee := Employee{}
    decodingErr := json.NewDecoder(r.Body).Decode(&employee)
    if decodingErr != nil{
        log.Print("error occurred while decoding employee data :: ", decodingErr)
        return
    }

    log.Printf("updating employee id :: %s with firstName as :: %s and lastName as :: %s ", employee.Id,
                                                                employee.FirstName, employee.LastName)
    response, err := resty.R().
            SetBody(Employee{Id: employee.Id, FirstName:employee.FirstName, LastName: employee.LastName}).
                                                                Put(WEB_SERVICE_HOST + "/employee/update")

    if err != nil{
        log.Print("error occurred while updating employee :: ", err)
        return
    }
    printOutput(response, err)
    fmt.Fprintf(w, response.String())
}

func deleteEmployee(w http.ResponseWriter, r *http.Request){
    employee := Employee{}
    decodingErr := json.NewDecoder(r.Body).Decode(&employee)
    if decodingErr != nil{
        log.Print("error occurred while decoding employee data :: ", decodingErr)
        return
    }
    log.Printf("deleting employee id :: %s with firstName as :: %s and lastName as :: %s ", employee.Id,
                                                            employee.FirstName, employee.LastName)
    response, err := resty.R().
        SetBody(Employee{Id: employee.Id, FirstName: employee.FirstName, LastName: employee.LastName}).
                                                            Delete(WEB_SERVICE_HOST + "/employee/delete")
    if err != nil{
        log.Print("error occurred while deleting employee :: ", err)
        return
    }
    printOutput(response, err)
    fmt.Fprintf(w, response.String())
}

func printOutput(resp *resty.Response, err error){
    log.Println(resp, err)
}

func main(){
    router := mux.NewRouter().StrictSlash(false)
    router.HandleFunc("/employees", getEmployees).Methods("GET")

    employee := router.PathPrefix("/employee").Subrouter()
    employee.HandleFunc("/add", addEmployee).Methods("POST")
    employee.HandleFunc("/update", updateEmployee).Methods("PUT")
    employee.HandleFunc("/delete", deleteEmployee).Methods("DELETE")

    err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
    if err != nil{
        log.Fatal("error starting http server : ", err)
        return
    }
}
        </code></pre>
    <li>Запустите программу с помощью следующей команды:</li>
        <p class="terminal">
            $ go run http-rest-client.go
        </p>
</ol>

<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8090.</p>
<p>Затем выполнение запроса GET к клиенту REST из командной строки следующим образом предоставит
    вам список всех сотрудников службы:</p>

<p class="terminal">
    $ curl -X GET http://localhost:8090/employees
    
    [{"id":"1","firstName":"Foo","lastName":"Bar"},
        {"id":"2","firstName":"Baz","lastName":" ...

</p>
<p>Аналогично запустите http-rest-post.go, который мы создали в одном из предыдущих рецептов, в
    отдельном терминале, выполнив следующую команду:</p>
<p class="terminal">
    $ go run http-rest-post.go

</p>

<p>Выполните запрос POST к клиенту REST из командной строки следующим образом:</p>
<p class="terminal">
    $ curl -H "Content-Type: application/json" -X POST -d '{"Id":"3",
             "firstName":"Quux", "lastNa ...
    
    [{"id":"1","firstName":"Foo","lastName":"Bar"},
                {"id":"2","firstName":"Baz","lastName":" ...

</p>
<p>Это добавит сотрудника в исходный статический список и вернет обновленный список
    сотрудников, который будет выглядеть, как показано на следующем снимке экрана:</p>
    <p><img src="static/images/picture4-5.png" </p>
<p>Давайте разберемся в написанной нами программе:</p>
<ol>
    <li>Используя import («encoding/json» «fmt» «log» «net/http» «github.com/gorilla/mux» resty
        «gopkg.in/resty.v1»), мы импортировали github.com/gorilla/mux в создайте Gorilla Mux Router
        и gopkg.in/resty.v1 с псевдонимом пакета resty, который является REST-клиентом Go и
        имеет различные обработчики для использования веб-службы RESTful.</li>
    <li>Используя const WEB_SERVICE_HOST string = «http://localhost:8080», мы объявили
        полный URL-адрес хоста веб-службы RESTful.</li>
        <p class="note">
            В зависимости от размера проекта вы можете переместить строку WEB_SERVICE_HOST в файл констант или в файл свойств
, что поможет вам переопределить ее значение во время выполнения.
        </p>
    <li>Затем мы определили обработчик getEmployees, в котором мы создаем новый объект запроса resty,
        вызывая его обработчик R(), вызываем метод Get, который выполняет запрос HTTP GET,
        получает ответ и записывает его в ответ HTTP.</li>
    <li>Аналогичным образом мы определили еще три обработчика, которые выполняют запросы POST, PUT и DELETE
        к службе RESTful, а также метод main(), в котором мы создаем экземпляр маршрутизатора gorilla/mux
        и регистрируем URL-путь /employees с помощью обработчика getEmployee и /employee/. add,
        /employee/update и /employee/delete с помощью
        обработчиков addEmployee, updateEmployee и deleteEmployee соответственно.</li>
</ol>

<h2>Создание вашего первого клиента ReactJS</h2>
<p>ReactJS — это декларативная библиотека JavaScript, которая помогает
    эффективно создавать пользовательские интерфейсы. Поскольку он работает на основе концепции виртуального DOM, он повышает
    производительность приложения, поскольку виртуальный DOM JavaScript работает быстрее, чем обычный DOM.
    В этом рецепте мы научимся создавать клиент ReactJS для отправки POST-запроса на
    HTTP-сервер, работающий локально.</p>


<h2>Готовимся ...</h2>
<p>Поскольку в нашем предыдущем рецепте мы уже создали HTTP-сервер, который принимает HTTP-
    запросы GET и POST, мы будем использовать ту же базу кода, что и наш HTTP-
    сервер.</p>
<p>Кроме того, этот рецепт предполагает, что на вашем компьютере установлен <i>npm</i> и у вас есть базовые
    знания о <i>npm</i> и <i>webpack</i>, который представляет собой сборщик модулей JavaScript.</p>

<p class="note">
    См. рецепт «Создание первого метода HTTP POST».
</p>

<h3>Как это сделать ...</h3>
<ol>
    <li>Создайте каталог responsejs-client, в котором мы будем хранить все исходные файлы ReactJS
        и HTTP-сервер, как показано ниже:</li>
        <p class="terminal">
            $ mkdir reactjs-client && cd reactjs-client && touch server.go
        </p>
    <li>Скопируйте следующий код на server.go:</li>
    <pre><code>
package main

import(
    "encoding/json"
    "log"
    "net/http"
    "github.com/gorilla/mux"
)

const(
    CONN_HOST = "localhost"
    CONN_PORT = "8080"
)

type Route struct{
    Name string
    Method string
    Pattern string
    HandlerFunc http.HandlerFunc
}

type Routes []Route

var routes = Routes{
    Route{
        "getEmployees",
        "GET",
        "/employees",
        getEmployees,
    },
    Route{
        "addEmployee",
        "POST",
        "/employee/add",
        addEmployee,
    },
}

type Employee struct{
    Id          string `json:"id"`
    FirstName   string `json:"firstName"`
    LastName    string `json:"lastName"`
}

type Employees []Employee

var employees []Employee

func init(){
    employees = Employees{
        Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
        Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
    }
}

func getEmployees(w http.ResponseWriter, r *http.Request){
    json.NewEncoder(w).Encode(employees)
}

func addEmployee(w http.ResponseWriter, r *http.Request){
    employee := Employee{}
    err := json.NewDecoder(r.Body).Decode(&employee)
    if err != nil{
        log.Println("error occurred while decoding employee data: ", err)
        return
    }
    log.Printf("adding employee id: %s with firstName as: %s and lastName as: %s ", employee.Id,
                                                        employee.FirstName, employee.LastName)
    employees = append(employees, Employee{Id: employee.Id,
                                    FirstName: employee.FirstName, LastName: employee.LastName})
    json.NewEncoder(w).Encode(employees)
}

func AddRoutes(router *mux.Router) *mux.Router{
    for _, route := range routes{
        router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(route.HandlerFunc)
    }
    return router
}

func main(){
    muxRouter := mux.NewRouter().StrictSlash(true)
    router := AddRoutes(muxRouter)
    router.PathPrefix("/").Handler(http.FileServer(http.Dir("./assets/")))
    
    err := http.ListenAndServe(CONN_HOST + ":" + CONN_PORT, router)
    if err != nil{
        log.Fatal("error starting http server: ", err)
        return
    }
}
    </code></pre>
    <li>Создайте еще один каталог с именем assets, в котором
        будут храниться все файлы кода нашего внешнего интерфейса, такие как .html, .js, .css и изображения, следующим образом:</li>
        <p class="terminal">
            $ mkdir assets && cd assets && touch index.html
        </p>
    <li>Скопируйте следующее содержимое в index.html:</li>
    <pre><code>
&lt;html&gt;
    &lt;head lang="en"&gt;
        &lt;meta charset="UTF-8" /&gt;
        &lt;title&gt;ReactJS Client&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="react"&gt;&lt;/div&gt;
        &lt;script src="/script.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </code></pre>
    <li>Перейдите в каталог responsejs-client и выполните <i>npm init</i>, чтобы создать package.json,
        где мы указываем все зависимости, необходимые для создания нашего React клиента, такие как
        React, React DOM, Webpack, Babel Loader, Babel Core, Babel Preset: ES2015 и Babel.
        Предустановка: React следующим образом:</li>
        <p class="terminal">
            $ cd responsejs-client && touch npm init
        </p>
        <p>Замените содержимое package.json следующим содержимым:</p>
        <pre><code>
            {
                "name": "reactjs-client",
                "version": "1.0.0",
                "description": "ReactJs Client",
                "keywords":
                [
                    "react"
                ],
                "author": "Arpit Aggarwal",
                "dependencies":
                {
                    "axios": "^0.18.0",
                    "react": "^16.2.0",
                    "react-dom": "^16.2.0",
                    "react-router-dom": "^4.2.2",
                    "webpack": "^4.2.0",
                    "webpack-cli": "^2.0.9",
                    "lodash": "^4.17.5"
                },
                "scripts":
                {
                    "build": "webpack",
                    "watch": "webpack --watch -d"
                },
                "devDependencies":
                {
                    "babel-core": "^6.18.2",
                    "babel-loader": "^7.1.4",
                    "babel-polyfill": "^6.16.0",
                    "babel-preset-es2015": "^6.18.0",
                    "babel-preset-react": "^6.16.0"
                }
            }
        </code></pre>
    <li>Создайте webpack.config.js, где мы будем настраивать веб-пакет следующим образом:</li>
    <p class="terminal">
        $ cd reactjs-client && touch webpack.config.js
    </p>
    <p>Скопируйте следующее содержимое в webpack.config.js:</p>
    <pre><code>
    var path = require('path');
    module.exports = {
                           resolve:
                        {
                            extensions: ['.js', '.jsx']
                        },
                        mode: 'development',
                        entry: './app/main.js',
                        cache: true,
                        output:
                        {
                            path: __dirname,
                            filename: './assets/script.js'
                        },
                        module:
                        {
                            rules:
                        [
                        {
                            test: path.join(__dirname, '.'),
                            exclude: /(node_modules)/,
                            loader: 'babel-loader',
                            query:
                        {
                            cacheDirectory: true,
                            presets: ['es2015', 'react']
                        }
                        }
                        ]
                        }
                    };
    </code></pre>
    <li>Создайте точку входа для веб-пакета (reactjs-client/app/main.js), выполнив
        следующие команды:</li>
        <p class="terminal">
            $ cd actjs-client && mkdir app && cd app && touch main.js
        </p>
        <p>Скопируйте следующее содержимое в main.js:</p>
        <pre><code>
            'use strict';
            const React = require('react');
            const ReactDOM = require('react-dom')
            import EmployeeApp from './components/employee-app.jsx'
            ReactDOM.render
            (
                &lt;EmployeeApp /&gt;,
            document.getElementById('react')
            )   
        </code></pre>
        <li>Определите ReactApp вместе с его дочерними компонентами, выполнив следующие
            команды:</li>
            <p class="terminal">
                $ cd reactjs-client && mkdir components && cd components && touch react-app.jsx
            </p>
            <p>Скопируйте следующее содержимое в responsejs-client/app/comComponents/employee-app.jsx:</p>
            <pre><code>
                'use strict';
                const React = require('react');
                var axios = require('axios');
                import EmployeeList from './employee-list.jsx'
                import AddEmployee from './add-employee.jsx'
                export default class EmployeeApp extends React.Component
                {
                    constructor(props)
                {
                super(props);
                this.state = {employees: []};
                this.addEmployee = this.addEmployee.bind(this);
                this.Axios = axios.create
                (
                {
                headers: {'content-type': 'application/json'}
                }
                );
                }
                componentDidMount()
                {
                let _this = this;
                this.Axios.get('/employees')
                .then
                (
                function (response)
                {
                _this.setState({employees: response.data});
                }
                )
                .catch(function (error) { });
                }
                addEmployee(employeeName)
                {
                let _this = this;
                this.Axios.post
                (
                '/employee/add',
                {
                firstName: employeeName
                }
                )
                .then
                (
                function (response)
                {
                _this.setState({employees: response.data});
                }
                )
                .catch(function (error) { });
                }
                render()
                {
                return
                (
                &lt;div&gt;
                &lt;AddEmployee addEmployee={this.addEmployee}/&gt;
                &lt;EmployeeList employees={this.state.employees}/&gt;
                &lt;/div&gt;
                )
                }
                }
            </code></pre>
            <p>Скопируйте следующее содержимое в responsejs-client/app/comComponents/employee.jsx:</p>
            <pre><code>
                const React = require('react');
                export default class Employee extends React.Component
                {
                    render()
                        {
                            return (
                                &lt;tr&gt;
                                &lt;td&gt;{this.props.employee.firstName}&lt;/td&gt;
                                &lt;/tr&gt;
                            )
                    }
                }
            </code></pre>
            <p>Скопируйте следующее содержимое в responsejs-client/app/comComponents/employee-list.jsx:</p>
            <pre><code>
                const React = require('react');
import Employee from './employee.jsx'
export default class EmployeeList extends React.Component
{
render()
{
var employees = this.props.employees.map
(
(employee, i) =&gt;
&lt;Employee key={i} employee={employee}/&gt;
);
return
(
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;FirstName&lt;/th&gt;
&lt;/tr&gt;
{employees}
&lt;/tbody&gt;
&lt;/table&gt;
)
}
}
            </code></pre>
            <p>Скопируйте следующее содержимое в responsejs-client/app/comComponents/add-employee.jsx:</p>
            <pre><code>
                import React, { Component, PropTypes } from 'react'
export default class AddEmployee extends React.Component
{
render()
{
return
(
<div>
<input type = 'text' ref = 'input' />
<button onClick = {(e) => this.handleClick(e)}>
Add
</button>
</div>
)
}
handleClick(e)
{
const node = this.refs.input
const text = node.value.trim()
this.props.addEmployee(text)
node.value = ''
}
}
            </code></pre>
            <p>Если все готово, структура каталогов должна выглядеть следующим образом:</p>
        <p><img src="static/images/picture4-6.png"/></p>
        <li>Перейдите в каталог реакции js-client и выполните следующие команды для установки
            модулей узла и сборки веб-пакета:</li>
            <p class="terminal">
                $ npm install
                $ npm run build
            </p>
        <li>Запустите программу с помощью следующей команды:
            </li>
            <p class="terminal">
                $ go run server.go
            </p>
</ol>

<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>При переходе по адресу http://localhost:8080 мы отобразим страницу клиента ReactJS, как показано на следующем
    снимке экрана:</p>
    <p><img src="static/images/picture4-7.png"/></p>
<p>Нажатие кнопки «Добавить» после заполнения текстового поля отправит POST-запрос на
    HTTP-сервер, работающий на порту 8080:</p>
    <p><img src="static/images/picture4-8.png"/></p>

<p>Затем, выполнив запрос GET из командной строки следующим образом, вы получите список
    всех статических сотрудников:</p>
<p class="terminal">
    $ curl -X GET http://localhost:8080/employees

</p>
<p>Это будет рядом с недавно добавленным, а именно:</p>
<p class="terminal">
    [{"id":"1","firstName":"Foo","lastName":"Bar"},{"id":"2","firstName":"Baz",
                                                                    "lastName":" ...

</p>

<h2>Создание вашего первого клиента VueJS.</h2>
<p>VueJS с открытым исходным кодом является одной из постепенно адаптируемых и прогрессивных
    инфраструктур JavaScript, которые компании применяют для создания своих интерфейсов или клиентских пользовательских интерфейсов для Интернета.</p>
<p>В этом рецепте мы научимся создавать клиент на VueJS, который добавляет сотрудника,
    отправляющего запрос HTTP POST на HTTP-сервер, работающий локально.</p>

<h3>Готовимся ...</h3>
<p>Поскольку в одном из предыдущих рецептов мы уже создали HTTP-сервер, который принимает запросы GET и POST
    , мы будем использовать ту же базу кода, что и наш HTTP-сервер.</p>

<p class="note">
    См. рецепт «Создание первого метода HTTP POST».
</p>

<h3>Как это сделать ...</h3>
<ol>
    <li>Создайте каталог vuejs-client, в котором мы будем хранить все исходные файлы VueJS и
        HTTP-сервер, следующим образом:</li>
        <p class="terminal">
            $ mkdir vuejs-client && cd vuejs-client && touch server.go
        </p>
    <li>Скопируйте следующий код на server.go:</li>
    <pre><code>
package main

import(
    "encoding/json"
    "log"
    "net/http"
    "github.com/gorilla/mux"
)

const(
    CONN_HOST = "localhost"
    CONN_PORT = "8080"
)

type Route struct{
    Name string
    Method string
    Pattern string
    HandlerFunc http.HandlerFunc
}

type Routes []Route

var routes = Routes{
    Route{
        "getEmployees",
        "GET",
        "/employees",
        getEmployees,
    },
    Route{
        "addEmployee",
        "POST",
        "/employee/add",
        addEmployee,
    },
}

type Employee struct{
    Id          string `json:"id"`
    FirstName   string `json:"firstName"`
    LastName    string `json:"lastName"`
}

type Employees []Employee

var employees []Employee

func init(){
    employees = Employees{
        Employee{Id: "1", FirstName: "Foo", LastName: "Bar"},
        Employee{Id: "2", FirstName: "Baz", LastName: "Qux"},
    }
}

func getEmployees(w http.ResponseWriter, r *http.Request){
    json.NewEncoder(w).Encode(employees)
}

func addEmployee(w http.ResponseWriter, r *http.Request){
    employee := Employee{}
    err := json.NewDecoder(r.Body).Decode(&employee)
    if err != nil{
        log.Print("error occurred while decoding employee data: ", err)
        return
    }
    log.Printf("adding employee id: %s with firstName as : %s and lastName as : %s ", employee.Id,
                                                            employee.FirstName, employee.LastName)
    employees = append(employees, Employee{Id: employee.Id,
                                    FirstName: employee.FirstName, LastName: employee.LastName})
    json.NewEncoder(w).Encode(employees)
}

func AddRoutes(router *mux.Router) *mux.Router{
    for _, route := range routes{
        router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(route.HandlerFunc)
    }
    return router
}

func main(){
    muxRouter := mux.NewRouter().StrictSlash(true)
    router := AddRoutes(muxRouter)
    router.PathPrefix("/").Handler(http.FileServer(http.Dir("./assets/")))

    err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, router)
    if err != nil{
        log.Fatal("error starting http server: ", err)
        return
    }
}
    </code></pre>
    <li>Создайте еще один каталог с именем assets, в котором
        будут храниться все файлы кода нашего внешнего интерфейса, такие как .html, .js, .css и изображения, следующим образом:</li>
    <p class="terminal">
        $ mkdir assets && cd assets && touch index.html && touch main.js
    </p>
    <li>Скопируйте следующее содержимое в index.html:</li>
    <pre><code>
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;VueJs Client&lt;/title&gt;
        &lt;script type = "text/javascript" src = "https://cdnjs.
                    cloudflare.com/ajax/libs/vue/2.4.0/vue.js"&gt;&lt;/script&gt;
        &lt;script type = "text/javascript" src="https://cdn.
                            jsdelivr.net/npm/vue-resource@1.5.0"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id = "form"&gt;
        &lt;h1&gt;{{ message }}&lt;/h1&gt;
        &lt;table&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;label for="id"&gt;Id&lt;/label&gt;&lt;/td&gt;
                &lt;td&gt;&lt;input type="text" value="" v-model="id"/&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;label for="firstName"&gt;FirstName&lt;/label&gt;&lt;/td&gt;
                &lt;td&gt;&lt;input type="text" value="" v-model="firstName"/&gt;
                &lt;td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;label for="lastName"&gt;LastName&lt;/label&gt;&lt;/td&gt;
                &lt;td&gt; &lt;input type="text" value="" v-model="lastName" /&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;&lt;a href="#" class="btn" @click="addEmployee"&gt;Add
                &lt;/a&gt;&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
        &lt;/div&gt;
        &lt;script type = "text/javascript" src = "main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
    </code></pre>
    <li>Скопируйте следующее содержимое в main.js:</li>
    <pre><code>
var vue_det = new Vue({
    el: '#form',
    data:{
        message: 'Employee Dashboard',
        id: '',
        firstName:'',
        lastName:''
    },
    methods:{
        addEmployee: function(){
            this.$http.post(
                '/employee/add',
                {
                id: this.id,
                firstName:this.firstName,
                lastName:this.lastName
                }
            )
            .then(
                response =>{
                    console.log(response);
                },
                error =>{
                    console.error(error);
                }
            );
        }
    }
});
    </code></pre>
    <p>Если все готово, структура каталогов должна выглядеть следующим образом:</p>
    <p><img src="static/images/picture4-9.png"/></p>
    <li>Запустите программу следующей командой:</li>
    <p class="terminal">
        $ go run server.go
    </p>
</ol>


<h3>Как это работает ...</h3>
<p>Как только мы запустим программу, HTTP-сервер начнет локально прослушивать порт 8080.</p>
<p>При переходе по адресу http://localhost:8080 мы отобразим клиентскую страницу VueJS, которая имеет
    HTML-форму с полями Id, FirstName и LastName, как показано на рисунке. на следующем
    скриншоте:</p>
    <p><img src="static/images/picture4-10.png"/></p>
<p>Нажатие кнопки «Добавить» после заполнения формы отправит POST-запрос на
    HTTP-сервер, работающий на порту 8080, как показано на следующем снимке экрана:</p>
    <p><img src="static/images/picture4-11.png"/></p>

<p>Затем, выполнив запрос GET из командной строки следующим образом, вы получите список
    всех статических сотрудников:</p>
<p class="terminal">
    $ curl -X GET http://localhost:8080/employees

</p>
<p>Это будет рядом с недавно добавленным следующим образом:</p>
<p class="terminal">
    [{"id":"1","firstName":"Foo","lastName":"Bar"},{"id":"2","firstName":"Baz",
                                                        "lastName":"  ...

</p>

</body>
</html>
